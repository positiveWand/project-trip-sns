# 테스트
## 배경
소프트웨어는 다양한 요구사항을 만족해야합니다. 모든 구현이 완료된 후에 의도한대로 동작하는지에 대한 검증을 할 수 있지만, 소프트웨어의 규모와 복잡도가 커지면 그런 방식의 검증은 번거롭습니다. 문제가 발생했을 때 문제 원인을 진단하기 위해 시스템 전체를 대상으로 검증을 수행해야 하기 때문입니다. 시스템의 크기가 증가함에 따라 검증해야하는 요소가 기하급수적으로 늘기 때문에 많은 시간과 노력이 필요합니다. 따라서 개발을 하면서 적절히 작은 단위의 테스트를 중간에 진행하는 것이 좋습니다. 하지만 검증에 집중하다보면 막상 구현이 미뤄져 프로젝트 진행이 늦춰지게 됩니다.

프로젝트를 진행하며 테스트의 필요성을 느낌과 동시에 너무 작은 단위를 대상으로 진행하는 테스트의 단점을 체감했습니다. 결과적으로 다음과 같은 방식으로 검증을 진행했습니다.

- 클라이언트와 서버를 분리한 테스트
- 반복 가능한 테스트

## MSW를 이용한 서버 모킹
클라이언트 테스트를 위해서 [MSW(Mock Service Worker)](https://mswjs.io/)를 사용했습니다. MSW는 [서비스 워커](https://developer.mozilla.org/ko/docs/Web/API/Service_Worker_API) 기술을 이용해 실제로 네트워크 요청을 보내고 응답하는 과정까지 모킹하기 때문에 쉽게 서버와 독립적인 테스트 환경을 구성할 수 있습니다.

### 서버 상태가 필요한 테스트
API 모커를 구현하면서 특히, 서버 상태를 필요로 하는 API를 모킹하면서 문제가 발생했습니다.

프로젝트의 서버 API는 기본적으로 REST API를 지향하지만 세션 인증 방식의 인증/인가 매커니즘을 사용합니다. 그렇기에 서버에서 세션 관련 상태를 유지하고 있습니다. 그리고 세션ID로 식별된 사용자는 비즈니스 정책에 따라 서비스가 인가됩니다. 이때, 인증/인가 상태에 따라 API 응답이 달라질 수 있습니다.

다양한 상황(올바른 응답이 반환된 상황, 응답이 거부된 상황 등)을 테스트 하기 위해 API 모커는 인증/인가 상태에 따라 응답이 달라져야 했습니다. 그래서 처음에는 다음과 같은 방법을 고려했습니다.

1. 인증/인가 로직 구현
2. 주석을 이용해 원하는 응답 메시지 반환

하지만 1번 방법은 사실상 간단한 서버를 구현하는 것과 다를 것이 없고 2번 방법은 API를 찾고 주석 처리를 켜고 끄는 번거로운 과정이 요구됩니다. 그래서 고민 끝에 아래와 같은 방법을 고안습니다.

- 인증/인가 관련 상태를 토큰 형태로 `config.ts` 파일에 보관
- 해당 토큰을 참조해 API 모커에서는 적절한 응답을 반환

토큰의 유무 혹은 논리값(true/false) 상태에 따라 인증/인가 상태를 판단하기 때문에 약간의 로직만을 추가해 관련 API를 쉽게 모킹했습니다. 테스트 시 `config.ts` 파일을 조작하기만 하면 원하는 서버 응답이 반환되도록 했습니다.

### 빌드 시 테스트 코드 제거
빌드 시 테스트 코드가 포함되는 문제를 발견했습니다. 테스트 코드는 개발 시에만 필요하기 때문에 배포 시에는 제외되어야합니다. 불필요한 용량만 차지하고 파일 전송 시간을 높이게 됩니다. 제외되어야하는 코드는 크게 2가지 입니다.

- 서비스 워커 코드(`/frontend/public/mockServiceWorker.js`)
- API 핸들링 코드(`/frontend/src/mocks/*`)

서비스 워커 코드는 `public` 디렉토리에 위치하기 때문에 Vite의 [기본 동작](https://ko.vite.dev/guide/assets.html#the-public-directory)상 빌드에 무조건 포함되게 됩니다. 또한 API 핸들링 코드는 Javascript 코드에서 import되어 사용되기 때문에 번들링 시 자동으로 포함됩니다.

다음과 같은 방식으로 두 요소를 빌드에서 제외했습니다.

- 서비스 워커 코드 - 빌드하면서 파일을 제거하는 Vite 플러그인 정의
- API 핸들링 코드 - Rollup의 Tree Shaking 활용, `process.env.NODE_ENV` 환경변수 값에 따른 조건부 import를 이용해 빌드에서 제외
  - `process.env.NODE_ENV`의 값이 `'development'`인 경우 import되지 않음

![테스트 코드 제거 전](./image/test-build-before.png)

![테스트 코드 제거 후](./image/test-build-after.png)

위 이미지가 테스트 코드 제거 전이고, 아래 이미지가 테스트 코드 제거 후입니다. 빌드 용량이 크게 감소한 것을 확인할 수 있습니다.

### 참조
- [`config.ts`](https://github.com/positiveWand/project-trip-sns/blob/main/frontend/src/mocks/config.ts) - 인증/인가 관련 상태 보관
- [`vite.config.ts`](https://github.com/positiveWand/project-trip-sns/blob/main/frontend/vite.config.ts) - 빌드 시 `mockServiceWorker.js` 제거
- [`init.ts`](https://github.com/positiveWand/project-trip-sns/blob/main/frontend/src/init.ts) - Tree Shaking을 활성화하기 위한 조건부 import

## Postman을 이용한 테스트
서버 테스트를 위해서 [Postman](https://www.postman.com/)를 사용했습니다. Postman을 사용하면서 느낀 장점은 아래와 같습니다.

- 쉽고 빠른 요청 메시지 구성
  - 쿼리 파라미터, HTTP Body를 쉽게 넣고 빼고 바꾸는 것이 가능합니다
- 반복가능한 테스트
  - 엔드포인트별로 Request를 만들어두면 이후 반복적으로 사용할 수 있습니다
- Performance Run 제공
  - API 성능을 측정할 수 있는 기능
  - 이 기능을 활용해 부하테스트를 진행하고 관련 성능 지표를 시각화된 형태로 확인할 수 있습니다

## 아쉬운 점
### 작지 않은 테스트 단위
시스템 컴포넌트를 신뢰하고 사용하기 위해서는 단위테스트를 하는 것이 바람직하다고 생각합니다. 하지만 단위테스트를 제대로 진행하기 위해서는 테스트 프레임워크/라이브러리에 대한 학습이 필요한 상황이었습니다. 이는 자칫 구현 자체를 과도하게 지연할 우려가 있었기에 최소한으로 서버와 클라이언트를 나누어 테스트를 진행했습니다.

### 수동으로 진행한 테스트
시스템에 요소가 추가/제거/변경되면서 기존 요소들에 영향이 있는지 대한 우려가 항상 존재합니다. 따라서 기존 요소들에 대한 테스트를 시스템 변경 시점마다 진행하는 것이 좋습니다. 하지만 수동으로 테스트를 진행하면 번거롭고 테스트의 일관성도 떨어집니다. 테스트 프레임워크/라이브러리를 충분히 익혔다면 코드로 테스트를 작성하기 때문에 테스트를 쉽고 빠르게 진행할 수 있었을 것입니다.